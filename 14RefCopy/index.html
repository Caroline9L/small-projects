<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>JS Reference VS Copy</title>
</head>

<body>

	<script>
		// start with strings, numbers and booleans
		// let age = 100;
		// let age2 = age;
		// console.log(age, age2);
		// age = 200;
		// console.log(age, age2);

		// let name = 'Wes';
		// let name2 = name;
		// console.log(name, name2);
		// name = 'Wesley';
		// console.log(name, name2);


		// Let's say we have an array
		const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

		// and we want to make a copy of it.
		const team = players;
		console.log(players, team);

		// You might think we can just do something like this:
		// team[3] = "Lux"; //team is a reference to the original array, changes original

		// however what happens when we update that array?
		// now here is the problem!
		// oh no - we have edited the original array too!
		// Why? It's because that is an array reference, not an array copy. They both point to the same array!
		// So, how do we fix this? We take a copy instead!

		// one way
		const team2 = players.slice(); //passing nothing copies original array

		// or create a new array and concat the old one in
		const team3 = [].concat(players); //takes items and puts them in new array team 3
		
		// or use the new ES6 Spread
		const team4 = [...players]; //takes every item from iterable and puts it in this new array
		team4[3] = 'heeeee hawwww';
		console.log(team4);

		const team5 = Array.from(players);

		// now when we update it, the original one isn't changed
		// The same thing goes for objects, let's say we have a person object
		// with Objects
		const person = {
			name: 'Wes Bos',
			age: 80
		};

		// and think we make a copy:
		// const captain = person;
		// captain.number = 99; //we actually just make a reference to the original

		// how do we take a copy instead?
		const cap2 = Object.assign({}, person, { number: 99, age: 12 }); //start with a blank object, pass it the object you want to copy, then add the properties you want to override
		console.log(cap2);

		// We will hopefully soon see the object ...spread
		const cap3 = {...person}; //apparently this works as of Sept. 2017 in Chrome

		// Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
		const wes = {
			name: 'Wes',
			age: 100,
			social: {
				twitter: '@wesbos',
				facebook: 'wesbos.developer'
			}
		}

		console.log(wes);

		const dev = Object.assign({}, wes);
		//updates will be in copied object for name and age, but social will replace the orginal characters in the object

		const dev2 = JSON.parse(JSON.stringify(wes));
		//makes your object into a string.  Changes won't affect original object, but this is no longer an object. .parse turns it back into an object

	</script>

</body>

</html>